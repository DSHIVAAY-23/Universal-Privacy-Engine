//! Data provider trait definition

use async_trait::async_trait;
use super::error::DataError;

/// Trait for fetching data from external sources
///
/// This trait abstracts over different data sources (HTTP, IPFS, blockchain oracles, etc.)
/// and provides a unified interface for data ingestion into the Privacy Engine.
///
/// ## Future: zkTLS Integration
///
/// Eventually, implementations will be secured by zkTLS (TLSNotary/DECO) to provide
/// cryptographic proof of data authenticity without revealing the full TLS session.
///
/// ## Example
///
/// ```ignore
/// use universal_privacy_engine_core::data_source::{DataProvider, HttpProvider};
///
/// #[tokio::main]
/// async fn main() {
///     let provider = HttpProvider::new();
///     let balance = provider.fetch(
///         "https://api.bank.com/account/123",
///         "data.balance"
///     ).await.unwrap();
/// }
/// ```
#[async_trait]
pub trait DataProvider: Send + Sync {
    /// Fetch data from a source with an optional query
    ///
    /// # Arguments
    ///
    /// * `source` - URL or identifier for the data source (e.g., "https://api.example.com/data")
    /// * `query` - Query string to extract specific fields (e.g., "account.balance", "data[0].value")
    ///
    /// # Returns
    ///
    /// Raw bytes of the fetched and extracted data
    ///
    /// # Errors
    ///
    /// Returns `DataError` if:
    /// - HTTP request fails
    /// - JSON parsing fails
    /// - Requested field is not found
    /// - Network error occurs
    ///
    /// # Example Query Syntax
    ///
    /// - `"balance"` - Top-level field
    /// - `"account.balance"` - Nested field
    /// - `"items[0]"` - Array indexing
    /// - `"data.users[2].name"` - Complex path
    async fn fetch(&self, source: &str, query: &str) -> Result<Vec<u8>, DataError>;
    
    /// Verify TLS signature (zkTLS integration point)
    ///
    /// This method will eventually verify cryptographic proofs of TLS sessions
    /// generated by TLSNotary or DECO protocol.
    ///
    /// # Current Status
    ///
    /// **PLACEHOLDER**: Currently returns `true` without verification.
    /// See implementation for detailed TODO on zkTLS integration.
    ///
    /// # Future Behavior
    ///
    /// Will verify:
    /// - TLS session proof validity
    /// - Notary signature
    /// - Timestamp freshness
    /// - Certificate chain
    ///
    /// # Returns
    ///
    /// `true` if verification succeeds, `false` otherwise
    fn verify_tls_signature(&self) -> bool;
}
