// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title Universal Privacy Engine Verifier
/// @notice Wraps SP1 Groth16/PLONK verifier with a universal interface
/// @dev Auto-generated by VeriVault verifier generator
/// @dev This contract provides a standardized interface for verifying zero-knowledge proofs
///      generated by the SP1 zkVM, enabling privacy-preserving computations on-chain.
contract UniversalVerifier {
    
    // ═══════════════════════════════════════════════════════════════════════════
    // State Variables
    // ═══════════════════════════════════════════════════════════════════════════
    
    /// @notice Program verification key (commitment to the zkVM program)
    /// @dev This is the hash of the compiled guest program ELF
    ///      It ensures that only proofs from the correct program are accepted
    bytes32 public immutable programVKey;
    
    /// @notice SP1 verifier contract address
    /// @dev This contract performs the actual cryptographic verification
    ISP1Verifier public immutable sp1Verifier;
    
    // ═══════════════════════════════════════════════════════════════════════════
    // Events
    // ═══════════════════════════════════════════════════════════════════════════
    
    /// @notice Emitted when a proof is successfully verified
    /// @param sender Address that submitted the proof
    /// @param programId Verification key of the program
    /// @param publicValuesHash Hash of the public values committed in the proof
    event ProofVerified(
        address indexed sender,
        bytes32 indexed programId,
        bytes32 publicValuesHash
    );
    
    // ═══════════════════════════════════════════════════════════════════════════
    // Constructor
    // ═══════════════════════════════════════════════════════════════════════════
    
    /// @notice Initialize the verifier with SP1 verifier address
    /// @param _sp1Verifier Address of the deployed SP1 verifier contract
    constructor(address _sp1Verifier) {
        require(_sp1Verifier != address(0), "Invalid SP1 verifier address");
        
        // Set program verification key from template
        programVKey = {{ program_vkey }};
        
        // Set SP1 verifier contract
        sp1Verifier = ISP1Verifier(_sp1Verifier);
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // External Functions
    // ═══════════════════════════════════════════════════════════════════════════
    
    /// @notice Verify a zero-knowledge proof
    /// @dev This function wraps the SP1 verifier with additional event emission
    ///      and standardized error handling
    /// @param publicValues Public inputs/outputs of the computation (ABI-encoded)
    /// @param proofBytes The zero-knowledge proof (Groth16/PLONK proof bytes)
    /// @return success True if verification succeeds, reverts otherwise
    function verifyProof(
        bytes calldata publicValues,
        bytes calldata proofBytes
    ) external returns (bool success) {
        // Verify proof using SP1 verifier
        // This will revert if verification fails
        sp1Verifier.verifyProof(programVKey, publicValues, proofBytes);
        
        // Emit verification event
        emit ProofVerified(
            msg.sender,
            programVKey,
            keccak256(publicValues)
        );
        
        return true;
    }
    
    /// @notice Get the program verification key
    /// @return vkey The 32-byte verification key
    function getProgramVKey() external view returns (bytes32 vkey) {
        return programVKey;
    }
    
    /// @notice Get the SP1 verifier address
    /// @return verifier The address of the SP1 verifier contract
    function getSP1Verifier() external view returns (address verifier) {
        return address(sp1Verifier);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Interfaces
// ═══════════════════════════════════════════════════════════════════════════

/// @title ISP1Verifier
/// @notice Interface for SP1 proof verification
/// @dev This interface abstracts the SP1 verifier contract
///      In production, this would be the actual SP1 Groth16/PLONK verifier
interface ISP1Verifier {
    /// @notice Verify a zero-knowledge proof
    /// @param programVKey Verification key of the program
    /// @param publicValues Public inputs/outputs (ABI-encoded)
    /// @param proofBytes The proof bytes
    /// @dev Reverts if verification fails
    function verifyProof(
        bytes32 programVKey,
        bytes calldata publicValues,
        bytes calldata proofBytes
    ) external view;
}

// ═══════════════════════════════════════════════════════════════════════════
// Mock SP1 Verifier (Development Only)
// ═══════════════════════════════════════════════════════════════════════════

/// @title MockSP1Verifier
/// @notice Mock implementation of SP1 verifier for development and testing
/// @dev ⚠️ WARNING: This is a MOCK verifier for development only!
/// @dev DO NOT deploy to production. Use real SP1 verifier instead.
/// @dev Mock verifier does not perform actual cryptographic verification.
contract MockSP1Verifier is ISP1Verifier {
    
    /// @notice Mapping of allowed program verification keys
    mapping(bytes32 => bool) public allowedPrograms;
    
    /// @notice Event emitted when a proof is "verified" (mock)
    event MockProofVerified(bytes32 programVKey, uint256 publicValuesLength);
    
    /// @notice Initialize mock verifier with allowed programs
    /// @param _allowedPrograms Array of program VKeys to allow
    constructor(bytes32[] memory _allowedPrograms) {
        for (uint256 i = 0; i < _allowedPrograms.length; i++) {
            allowedPrograms[_allowedPrograms[i]] = true;
        }
    }
    
    /// @notice Mock proof verification
    /// @dev This does NOT perform real cryptographic verification
    /// @dev Only checks that the program is allowed and inputs are non-empty
    function verifyProof(
        bytes32 programVKey,
        bytes calldata publicValues,
        bytes calldata proofBytes
    ) external view override {
        require(allowedPrograms[programVKey], "MockSP1: Program not allowed");
        require(publicValues.length > 0, "MockSP1: Empty public values");
        require(proofBytes.length > 0, "MockSP1: Empty proof");
        
        // ⚠️ MOCK: In production, this would verify the actual ZK proof
        // For now, we just check basic validity and return
    }
    
    /// @notice Add an allowed program
    /// @param programVKey The program verification key to allow
    function addAllowedProgram(bytes32 programVKey) external {
        allowedPrograms[programVKey] = true;
    }
}
